<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
  <title>dplyr on goonR blog</title>
  <link>/tags/dplyr/</link>
  <description>Recent content in dplyr on goonR blog</description>
  <generator>Hugo -- gohugo.io</generator>
<language>en-us</language>
<lastBuildDate>Tue, 19 Mar 2019 00:00:00 +0000</lastBuildDate>

<atom:link href="/tags/dplyr/index.xml" rel="self" type="application/rss+xml" />


<item>
  <title>Using Scoped dplyr verbs </title>
  <link>/2019/03/19/using-scoped-dplyr-verbs/</link>
  <pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate>
  
<guid>/2019/03/19/using-scoped-dplyr-verbs/</guid>
  <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Over the past several months, I have really started to increase the amount that I have been using scoped &lt;code&gt;dplyr&lt;/code&gt; verbs. For those of you who don’t know about these functions, they are handy variants to the normal &lt;code&gt;dplyr&lt;/code&gt; verbs, such as &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;mutate&lt;/code&gt;, and &lt;code&gt;summarize&lt;/code&gt;, that allow you to target multiple columns or all of your columns. These functions allow for you to save yourself time and typing when you want to apply either one or multiple functions to more than one column, a group of columns, or to all of your columns. This post will walk through a few of the ones I use on a regular basis and how I use them!&lt;/p&gt;
&lt;p&gt;These scoped verbs typically come in three different flavors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_if&lt;/code&gt; - This allows you to target all columns that mean a specific condition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_at&lt;/code&gt; - This allows you to target specific columns by name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_all&lt;/code&gt; - As the name implies, this will apply a function to every column of the data set&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before we get started, let’s go ahead and load the libraries we will be using.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
library(ggplot2)
library(tibble)
library(stringr)
library(gt) # for the sp500 dataset
library(janitor)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;if&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;code&gt;_if&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;Let’s first take a look at &lt;code&gt;mutate_if&lt;/code&gt; by looking at an example where we want to convert factors to character variables. The data set we will be using for this example is &lt;code&gt;diamonds&lt;/code&gt; in the &lt;code&gt;ggplot2&lt;/code&gt; package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;diamonds&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 53,940 x 10
##    carat cut       color clarity depth table price     x     y     z
##    &amp;lt;dbl&amp;gt; &amp;lt;ord&amp;gt;     &amp;lt;ord&amp;gt; &amp;lt;ord&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 0.23  Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43
##  2 0.21  Premium   E     SI1      59.8    61   326  3.89  3.84  2.31
##  3 0.23  Good      E     VS1      56.9    65   327  4.05  4.07  2.31
##  4 0.290 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63
##  5 0.31  Good      J     SI2      63.3    58   335  4.34  4.35  2.75
##  6 0.24  Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48
##  7 0.24  Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47
##  8 0.26  Very Good H     SI1      61.9    55   337  4.07  4.11  2.53
##  9 0.22  Fair      E     VS2      65.1    61   337  3.87  3.78  2.49
## 10 0.23  Very Good H     VS1      59.4    61   338  4     4.05  2.39
## # ... with 53,930 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, there are three columns of factors in the data set (&lt;code&gt;ord&lt;/code&gt; is just an ordered factor) - &lt;code&gt;cut&lt;/code&gt;, &lt;code&gt;color&lt;/code&gt;, and &lt;code&gt;clarity&lt;/code&gt;. If you weren’t using scoped verbs, then you would convert them with something like this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;diamonds %&amp;gt;% 
  mutate(
    cut = as.character(cut),
    color = as.character(color),
    clarity = as.character(clarity)
  )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 53,940 x 10
##    carat cut       color clarity depth table price     x     y     z
##    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 0.23  Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43
##  2 0.21  Premium   E     SI1      59.8    61   326  3.89  3.84  2.31
##  3 0.23  Good      E     VS1      56.9    65   327  4.05  4.07  2.31
##  4 0.290 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63
##  5 0.31  Good      J     SI2      63.3    58   335  4.34  4.35  2.75
##  6 0.24  Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48
##  7 0.24  Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47
##  8 0.26  Very Good H     SI1      61.9    55   337  4.07  4.11  2.53
##  9 0.22  Fair      E     VS2      65.1    61   337  3.87  3.78  2.49
## 10 0.23  Very Good H     VS1      59.4    61   338  4     4.05  2.39
## # ... with 53,930 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this certainly works, it is easy to see how this method can get out of hand rather quickly. Now with the scoped variant, it is much cleaner. You have to pass a predicate function that will return &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt; for the column (e.g. &lt;code&gt;is.factor&lt;/code&gt;) and then it will apply the function (e.g. &lt;code&gt;as.character&lt;/code&gt;) to all columns that return &lt;code&gt;TRUE&lt;/code&gt; from the predicate.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;diamonds %&amp;gt;% 
  mutate_if(is.factor, as.character)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 53,940 x 10
##    carat cut       color clarity depth table price     x     y     z
##    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 0.23  Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43
##  2 0.21  Premium   E     SI1      59.8    61   326  3.89  3.84  2.31
##  3 0.23  Good      E     VS1      56.9    65   327  4.05  4.07  2.31
##  4 0.290 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63
##  5 0.31  Good      J     SI2      63.3    58   335  4.34  4.35  2.75
##  6 0.24  Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48
##  7 0.24  Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47
##  8 0.26  Very Good H     SI1      61.9    55   337  4.07  4.11  2.53
##  9 0.22  Fair      E     VS2      65.1    61   337  3.87  3.78  2.49
## 10 0.23  Very Good H     VS1      59.4    61   338  4     4.05  2.39
## # ... with 53,930 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The conversion of factors (and other datatypes) is probably the thing I use &lt;code&gt;mutate_if&lt;/code&gt; for the most, but you can use it for anything that has to be applied to all columns that meet certain conditions. If we wanted to add 10% of the mean of each numeric column to every value in that column (this is not practical, but just as an illustration) you could do the following.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;diamonds %&amp;gt;% 
  mutate_if(is.numeric, list(~.+0.1*mean(., na.rm = TRUE)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 53,940 x 10
##    carat cut       color clarity depth table price     x     y     z
##    &amp;lt;dbl&amp;gt; &amp;lt;ord&amp;gt;     &amp;lt;ord&amp;gt; &amp;lt;ord&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 0.310 Ideal     E     SI2      67.7  60.7  719.  4.52  4.55  2.78
##  2 0.290 Premium   E     SI1      66.0  66.7  719.  4.46  4.41  2.66
##  3 0.310 Good      E     VS1      63.1  70.7  720.  4.62  4.64  2.66
##  4 0.370 Premium   I     VS2      68.6  63.7  727.  4.77  4.80  2.98
##  5 0.390 Good      J     SI2      69.5  63.7  728.  4.91  4.92  3.10
##  6 0.320 Very Good J     VVS2     69.0  62.7  729.  4.51  4.53  2.83
##  7 0.320 Very Good I     VVS1     68.5  62.7  729.  4.52  4.55  2.82
##  8 0.340 Very Good H     SI1      68.1  60.7  730.  4.64  4.68  2.88
##  9 0.300 Fair      E     VS2      71.3  66.7  730.  4.44  4.35  2.84
## 10 0.310 Very Good H     VS1      65.6  66.7  731.  4.57  4.62  2.74
## # ... with 53,930 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; The notations for passing either anonymous functions (such as above) or multiple functions has changed in the release of &lt;code&gt;dplyr 0.8.0&lt;/code&gt;. Previously the above code would read &lt;code&gt;mutate_if(is.numeric, funs(.+0.1*mean(., na.rm=TRUE)))&lt;/code&gt;. The &lt;code&gt;funs&lt;/code&gt; function has been soft deprecated in the new release. This means that it can still be used but the newer implementation should be used as it will either no longer be supported or will be removed later. Running the &lt;code&gt;mutate_if&lt;/code&gt; call with &lt;code&gt;funs&lt;/code&gt; results in the following warning message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Warning message:
funs() is soft deprecated as of dplyr 0.8.0
please use list() instead
# Before:
funs(name = f(.)
# After: 
list(name = ~f(.))
This warning is displayed once per session.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, the original columns are modified to represent the new value. If you wanted to create new columns for all of the columns that this predicate function applies to, you can give the function a name in our list. The name of the function is appended to the name of every column that it applies to with a &lt;code&gt;_&lt;/code&gt; as a separator.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;diamonds %&amp;gt;% 
  mutate_if(is.numeric, list(&amp;quot;new&amp;quot; = ~.+0.1*mean(., na.rm = TRUE)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 53,940 x 17
##    carat cut   color clarity depth table price     x     y     z carat_new
##    &amp;lt;dbl&amp;gt; &amp;lt;ord&amp;gt; &amp;lt;ord&amp;gt; &amp;lt;ord&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
##  1 0.23  Ideal E     SI2      61.5    55   326  3.95  3.98  2.43     0.310
##  2 0.21  Prem~ E     SI1      59.8    61   326  3.89  3.84  2.31     0.290
##  3 0.23  Good  E     VS1      56.9    65   327  4.05  4.07  2.31     0.310
##  4 0.290 Prem~ I     VS2      62.4    58   334  4.2   4.23  2.63     0.370
##  5 0.31  Good  J     SI2      63.3    58   335  4.34  4.35  2.75     0.390
##  6 0.24  Very~ J     VVS2     62.8    57   336  3.94  3.96  2.48     0.320
##  7 0.24  Very~ I     VVS1     62.3    57   336  3.95  3.98  2.47     0.320
##  8 0.26  Very~ H     SI1      61.9    55   337  4.07  4.11  2.53     0.340
##  9 0.22  Fair  E     VS2      65.1    61   337  3.87  3.78  2.49     0.300
## 10 0.23  Very~ H     VS1      59.4    61   338  4     4.05  2.39     0.310
## # ... with 53,930 more rows, and 6 more variables: depth_new &amp;lt;dbl&amp;gt;,
## #   table_new &amp;lt;dbl&amp;gt;, price_new &amp;lt;dbl&amp;gt;, x_new &amp;lt;dbl&amp;gt;, y_new &amp;lt;dbl&amp;gt;,
## #   z_new &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similar to &lt;code&gt;mutate_if&lt;/code&gt;, &lt;code&gt;summarize_if&lt;/code&gt;/&lt;code&gt;summarise_if&lt;/code&gt; works by allowing you to select all the columns that meet a certain condition and summarizing those columns with a given function. It should be noted that in this case, just as with &lt;code&gt;summarize&lt;/code&gt;, a function has to be provided that will return only a single value. If you would like to see a way around that requirement, using &lt;code&gt;purrr&lt;/code&gt; and scoped verbs, you can see &lt;a href=&#34;https://tbradley1013.github.io/2018/10/01/calculating-quantiles-for-groups-with-dplyr-summarize-and-purrr-partial/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let’s see how &lt;code&gt;summarize_if&lt;/code&gt; works:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;diamonds %&amp;gt;% 
  summarize_if(is.numeric, list(&amp;quot;mean&amp;quot; = mean, &amp;quot;median&amp;quot; = median))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 14
##   carat_mean depth_mean table_mean price_mean x_mean y_mean z_mean
##        &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1      0.798       61.7       57.5      3933.   5.73   5.73   3.54
## # ... with 7 more variables: carat_median &amp;lt;dbl&amp;gt;, depth_median &amp;lt;dbl&amp;gt;,
## #   table_median &amp;lt;dbl&amp;gt;, price_median &amp;lt;dbl&amp;gt;, x_median &amp;lt;dbl&amp;gt;,
## #   y_median &amp;lt;dbl&amp;gt;, z_median &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also create more custom predicates to be used for our &lt;code&gt;_if&lt;/code&gt; functions. Let’s create one that returns whether a column is numeric and has at least one value higher than 50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;higher_fifty &amp;lt;- function(x){
  if (is.numeric(x)){
    return(any(x &amp;gt; 50))
  } else {
    return(FALSE)
  }
}


diamonds %&amp;gt;% 
  summarize_if(higher_fifty, list(&amp;quot;mean&amp;quot; = mean))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 4
##   depth_mean table_mean price_mean y_mean
##        &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1       61.7       57.5      3933.   5.73&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another useful &lt;code&gt;_if&lt;/code&gt; variant is &lt;code&gt;select_if&lt;/code&gt;. You may want to select all of the numeric columns in the &lt;code&gt;diamonds&lt;/code&gt; data set for further analysis, and &lt;code&gt;select_if&lt;/code&gt; is perfect for this case. The implementation is the same as &lt;code&gt;mutate_if&lt;/code&gt; and &lt;code&gt;summarize_if&lt;/code&gt;, just instead of specifying a function to apply to the selected columns, you only specify a predicate function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;diamonds %&amp;gt;% 
  select_if(is.numeric)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 53,940 x 7
##    carat depth table price     x     y     z
##    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 0.23   61.5    55   326  3.95  3.98  2.43
##  2 0.21   59.8    61   326  3.89  3.84  2.31
##  3 0.23   56.9    65   327  4.05  4.07  2.31
##  4 0.290  62.4    58   334  4.2   4.23  2.63
##  5 0.31   63.3    58   335  4.34  4.35  2.75
##  6 0.24   62.8    57   336  3.94  3.96  2.48
##  7 0.24   62.3    57   336  3.95  3.98  2.47
##  8 0.26   61.9    55   337  4.07  4.11  2.53
##  9 0.22   65.1    61   337  3.87  3.78  2.49
## 10 0.23   59.4    61   338  4     4.05  2.39
## # ... with 53,930 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last scoped verb for the &lt;code&gt;_if&lt;/code&gt; variants is &lt;code&gt;filter&lt;/code&gt;. &lt;code&gt;filter_if&lt;/code&gt; is slightly different than the rest of the &lt;code&gt;_if&lt;/code&gt; variants, because in addition to operating on columns in the data frame based on a condition, it can also operate on the rows of the data frame based on a condition. This row-wise operation is handled by the &lt;code&gt;.vars_predicate&lt;/code&gt; argument in the scoped &lt;code&gt;filter&lt;/code&gt; verbs. This argument is used in conjunction with the helper predicate functions &lt;code&gt;all_vars&lt;/code&gt; and &lt;code&gt;any_vars&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For this example, we will use the &lt;code&gt;sp500&lt;/code&gt; data set from the &lt;code&gt;gt&lt;/code&gt; package. Let’s say that we want to filter all of the rows that did not have a value of greater than $2000 for the entire day. We can do that like this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gt::sp500 %&amp;gt;% 
  filter_if(is.numeric, all_vars(. &amp;gt; 2000))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 249 x 7
##    date        open  high   low close     volume adj_close
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
##  1 2015-12-31 2061. 2063. 2044. 2044. 2655330000     2044.
##  2 2015-12-30 2077. 2077. 2062. 2063. 2367430000     2063.
##  3 2015-12-29 2061. 2082. 2061. 2078. 2542000000     2078.
##  4 2015-12-28 2058. 2058. 2044. 2056. 2492510000     2056.
##  5 2015-12-24 2064. 2067. 2059. 2061. 1411860000     2061.
##  6 2015-12-23 2042. 2065. 2042. 2064. 3484090000     2064.
##  7 2015-12-22 2023. 2043. 2020. 2039. 3520860000     2039.
##  8 2015-12-21 2010. 2023. 2006. 2021. 3760280000     2021.
##  9 2015-12-18 2041. 2041. 2005. 2006. 6683070000     2006.
## 10 2015-12-17 2074. 2076. 2042. 2042. 4327390000     2042.
## # ... with 239 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;all_vars&lt;/code&gt; requires that all the columns returning &lt;code&gt;TRUE&lt;/code&gt; from the predicate meet the filter requirements. Conversely, &lt;code&gt;any_vars&lt;/code&gt; requires that only one of the columns meets the specified requirements.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;at&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;code&gt;_at&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;Now we can take a look at another variant of the dplyr verbs that allows us to target specific columns, &lt;code&gt;_at&lt;/code&gt;. These functions are super handy when you want to apply a function to numerous columns by name. For this example, lets use the ever useful &lt;code&gt;mtcars&lt;/code&gt; data set with the row names moved to a column named &lt;code&gt;cars&lt;/code&gt;. We will assign this modified tibble to &lt;code&gt;cars_tbl&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cars_tbl &amp;lt;- mtcars %&amp;gt;% 
  rownames_to_column(&amp;quot;car&amp;quot;) %&amp;gt;% 
  as_tibble()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s say that we want to normalize the &lt;code&gt;mpg&lt;/code&gt;, &lt;code&gt;hp&lt;/code&gt;, and &lt;code&gt;drat&lt;/code&gt; columns from zero to one. We can do that by writing a simple function and applying it to each column, like this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;norm_dat &amp;lt;- function(x){
  (x-min(x))/(max(x)-min(x))
}

cars_tbl %&amp;gt;% 
  mutate(
    mpg = norm_dat(mpg),
    hp = norm_dat(hp),
    drat = norm_dat(drat)
  )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 32 x 12
##    car     mpg   cyl  disp     hp  drat    wt  qsec    vs    am  gear  carb
##    &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 Mazd~ 0.451     6  160  0.205  0.525  2.62  16.5     0     1     4     4
##  2 Mazd~ 0.451     6  160  0.205  0.525  2.88  17.0     0     1     4     4
##  3 Dats~ 0.528     4  108  0.145  0.502  2.32  18.6     1     1     4     1
##  4 Horn~ 0.468     6  258  0.205  0.147  3.22  19.4     1     0     3     1
##  5 Horn~ 0.353     8  360  0.435  0.180  3.44  17.0     0     0     3     2
##  6 Vali~ 0.328     6  225  0.187  0      3.46  20.2     1     0     3     1
##  7 Dust~ 0.166     8  360  0.682  0.207  3.57  15.8     0     0     3     4
##  8 Merc~ 0.596     4  147. 0.0353 0.429  3.19  20       1     0     4     2
##  9 Merc~ 0.528     4  141. 0.152  0.535  3.15  22.9     1     0     4     2
## 10 Merc~ 0.374     6  168. 0.251  0.535  3.44  18.3     1     0     4     4
## # ... with 22 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just like with the previous example of converting factors to characters, this certainly works but can quickly become cumbersome when applying the same function to multiple columns in a data set. &lt;code&gt;mutate_at&lt;/code&gt; allows you to specifically target columns to apply a function to.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cars_tbl%&amp;gt;% 
  mutate_at(vars(mpg, hp, drat), list(~norm_dat))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 32 x 12
##    car     mpg   cyl  disp     hp  drat    wt  qsec    vs    am  gear  carb
##    &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 Mazd~ 0.451     6  160  0.205  0.525  2.62  16.5     0     1     4     4
##  2 Mazd~ 0.451     6  160  0.205  0.525  2.88  17.0     0     1     4     4
##  3 Dats~ 0.528     4  108  0.145  0.502  2.32  18.6     1     1     4     1
##  4 Horn~ 0.468     6  258  0.205  0.147  3.22  19.4     1     0     3     1
##  5 Horn~ 0.353     8  360  0.435  0.180  3.44  17.0     0     0     3     2
##  6 Vali~ 0.328     6  225  0.187  0      3.46  20.2     1     0     3     1
##  7 Dust~ 0.166     8  360  0.682  0.207  3.57  15.8     0     0     3     4
##  8 Merc~ 0.596     4  147. 0.0353 0.429  3.19  20       1     0     4     2
##  9 Merc~ 0.528     4  141. 0.152  0.535  3.15  22.9     1     0     4     2
## 10 Merc~ 0.374     6  168. 0.251  0.535  3.44  18.3     1     0     4     4
## # ... with 22 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see how handy this can become and how much time this can save you if you are repeating the same operation on numerous columns within a tibble. An second, but equally advantageous, use of &lt;code&gt;mutate_at&lt;/code&gt; is the &lt;em&gt;deselection&lt;/em&gt; of columns to which a function should be applied. Say that we want to apply our normalization function to every column except &lt;code&gt;car&lt;/code&gt;, &lt;code&gt;vs&lt;/code&gt; and &lt;code&gt;am&lt;/code&gt;, since they are binary columns. To do this we would use the same methods as your would if you were removing a column with &lt;code&gt;select&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cars_tbl %&amp;gt;% 
  mutate_at(vars(-c(car, vs, am)), list(~norm_dat))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 32 x 12
##    car     mpg   cyl   disp     hp  drat    wt  qsec    vs    am  gear
##    &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 Mazd~ 0.451   0.5 0.222  0.205  0.525 0.283 0.233     0     1   0.5
##  2 Mazd~ 0.451   0.5 0.222  0.205  0.525 0.348 0.3       0     1   0.5
##  3 Dats~ 0.528   0   0.0920 0.145  0.502 0.206 0.489     1     1   0.5
##  4 Horn~ 0.468   0.5 0.466  0.205  0.147 0.435 0.588     1     0   0  
##  5 Horn~ 0.353   1   0.721  0.435  0.180 0.493 0.3       0     0   0  
##  6 Vali~ 0.328   0.5 0.384  0.187  0     0.498 0.681     1     0   0  
##  7 Dust~ 0.166   1   0.721  0.682  0.207 0.526 0.160     0     0   0  
##  8 Merc~ 0.596   0   0.189  0.0353 0.429 0.429 0.655     1     0   0.5
##  9 Merc~ 0.528   0   0.174  0.152  0.535 0.419 1         1     0   0.5
## 10 Merc~ 0.374   0.5 0.241  0.251  0.535 0.493 0.452     1     0   0.5
## # ... with 22 more rows, and 1 more variable: carb &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s say that we want to get the mean, sd, median, and count of all values greater than the mean for the &lt;code&gt;mpg&lt;/code&gt;, &lt;code&gt;hp&lt;/code&gt;, and &lt;code&gt;drat&lt;/code&gt; columns. We can do that using the &lt;code&gt;summarize_at&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cars_summary &amp;lt;- cars_tbl %&amp;gt;% 
  summarize_at(vars(mpg, hp, drat), list(&amp;quot;mean&amp;quot; = mean, &amp;quot;sd&amp;quot; = sd, &amp;quot;median&amp;quot; = median, &amp;quot;n_higher_half&amp;quot; = ~sum(. &amp;gt; mean(.))))

cars_summary&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 12
##   mpg_mean hp_mean drat_mean mpg_sd hp_sd drat_sd mpg_median hp_median
##      &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1     20.1    147.      3.60   6.03  68.6   0.535       19.2       123
## # ... with 4 more variables: drat_median &amp;lt;dbl&amp;gt;, mpg_n_higher_half &amp;lt;int&amp;gt;,
## #   hp_n_higher_half &amp;lt;int&amp;gt;, drat_n_higher_half &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above example demonstrates how you can simply pass a function name to be applied to the column, and how you can pass slightly more complex functions to the &lt;code&gt;.funs&lt;/code&gt; argument using &lt;code&gt;.&lt;/code&gt; notation.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;all&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;code&gt;_all&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;_all&lt;/code&gt; variant works similarly to the other two, just now we are by default targeting &lt;em&gt;all&lt;/em&gt; of the columns in the data frame. This can be extremely useful if you want to perform transformations on all of the columns in your data set or get summary variables for all of the columns. One place this may be useful is if you are fitting multivariate models and want to normalize all of your variables. Let’s show how these functions work with a quick example of both &lt;code&gt;mutate_all&lt;/code&gt; and &lt;code&gt;summarize_all&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;First, if we want to normalize all of the columns in a data set, we can do that by applying the &lt;code&gt;norm_dat&lt;/code&gt; function defined above with &lt;code&gt;mutate_all&lt;/code&gt;. Let’s see what this looks like using the &lt;code&gt;USArrests&lt;/code&gt; data set.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;USArrests %&amp;gt;%
  mutate_all(norm_dat)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        Murder     Assault  UrbanPop       Rape
## 1  0.74698795 0.654109589 0.4406780 0.35917313
## 2  0.55421687 0.746575342 0.2711864 0.96124031
## 3  0.43975904 0.852739726 0.8135593 0.61240310
## 4  0.48192771 0.496575342 0.3050847 0.31524548
## 5  0.49397590 0.791095890 1.0000000 0.86046512
## 6  0.42771084 0.544520548 0.7796610 0.81136951
## 7  0.15060241 0.222602740 0.7627119 0.09819121
## 8  0.30722892 0.660958904 0.6779661 0.21963824
## 9  0.87951807 0.993150685 0.8135593 0.63565891
## 10 1.00000000 0.568493151 0.4745763 0.47803618
## 11 0.27108434 0.003424658 0.8644068 0.33333333
## 12 0.10843373 0.256849315 0.3728814 0.17829457
## 13 0.57831325 0.698630137 0.8644068 0.43152455
## 14 0.38554217 0.232876712 0.5593220 0.35400517
## 15 0.08433735 0.037671233 0.4237288 0.10335917
## 16 0.31325301 0.239726027 0.5762712 0.27648579
## 17 0.53614458 0.219178082 0.3389831 0.23255814
## 18 0.87951807 0.698630137 0.5762712 0.38501292
## 19 0.07831325 0.130136986 0.3220339 0.01291990
## 20 0.63253012 0.873287671 0.5932203 0.52971576
## 21 0.21686747 0.356164384 0.8983051 0.23255814
## 22 0.68072289 0.719178082 0.7118644 0.71834625
## 23 0.11445783 0.092465753 0.5762712 0.19638243
## 24 0.92168675 0.732876712 0.2033898 0.25322997
## 25 0.49397590 0.455479452 0.6440678 0.54005168
## 26 0.31325301 0.219178082 0.3559322 0.23514212
## 27 0.21084337 0.195205479 0.5084746 0.23772610
## 28 0.68674699 0.708904110 0.8305085 1.00000000
## 29 0.07831325 0.041095890 0.4067797 0.05684755
## 30 0.39759036 0.390410959 0.9661017 0.29715762
## 31 0.63855422 0.821917808 0.6440678 0.64082687
## 32 0.62048193 0.715753425 0.9152542 0.48578811
## 33 0.73493976 1.000000000 0.2203390 0.22739018
## 34 0.00000000 0.000000000 0.2033898 0.00000000
## 35 0.39156627 0.256849315 0.7288136 0.36434109
## 36 0.34939759 0.363013699 0.6101695 0.32816537
## 37 0.24698795 0.390410959 0.5932203 0.56847545
## 38 0.33132530 0.208904110 0.6779661 0.19638243
## 39 0.15662651 0.441780822 0.9322034 0.02583979
## 40 0.81927711 0.801369863 0.2711864 0.39276486
## 41 0.18072289 0.140410959 0.2203390 0.14211886
## 42 0.74698795 0.489726027 0.4576271 0.50645995
## 43 0.71686747 0.534246575 0.8135593 0.47028424
## 44 0.14457831 0.256849315 0.8135593 0.40310078
## 45 0.08433735 0.010273973 0.0000000 0.10077519
## 46 0.46385542 0.380136986 0.5254237 0.34625323
## 47 0.19277108 0.342465753 0.6949153 0.48837209
## 48 0.29518072 0.123287671 0.1186441 0.05167959
## 49 0.10843373 0.027397260 0.5762712 0.09043928
## 50 0.36144578 0.397260274 0.4745763 0.21447028&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is that easy! We can also create new names for the mutated columns in the same manner that was shown in the &lt;code&gt;_if&lt;/code&gt; section.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;USArrests %&amp;gt;% 
  mutate_all(list(&amp;quot;norm&amp;quot; = norm_dat))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Murder Assault UrbanPop Rape Murder_norm Assault_norm UrbanPop_norm
## 1    13.2     236       58 21.2  0.74698795  0.654109589     0.4406780
## 2    10.0     263       48 44.5  0.55421687  0.746575342     0.2711864
## 3     8.1     294       80 31.0  0.43975904  0.852739726     0.8135593
## 4     8.8     190       50 19.5  0.48192771  0.496575342     0.3050847
## 5     9.0     276       91 40.6  0.49397590  0.791095890     1.0000000
## 6     7.9     204       78 38.7  0.42771084  0.544520548     0.7796610
## 7     3.3     110       77 11.1  0.15060241  0.222602740     0.7627119
## 8     5.9     238       72 15.8  0.30722892  0.660958904     0.6779661
## 9    15.4     335       80 31.9  0.87951807  0.993150685     0.8135593
## 10   17.4     211       60 25.8  1.00000000  0.568493151     0.4745763
## 11    5.3      46       83 20.2  0.27108434  0.003424658     0.8644068
## 12    2.6     120       54 14.2  0.10843373  0.256849315     0.3728814
## 13   10.4     249       83 24.0  0.57831325  0.698630137     0.8644068
## 14    7.2     113       65 21.0  0.38554217  0.232876712     0.5593220
## 15    2.2      56       57 11.3  0.08433735  0.037671233     0.4237288
## 16    6.0     115       66 18.0  0.31325301  0.239726027     0.5762712
## 17    9.7     109       52 16.3  0.53614458  0.219178082     0.3389831
## 18   15.4     249       66 22.2  0.87951807  0.698630137     0.5762712
## 19    2.1      83       51  7.8  0.07831325  0.130136986     0.3220339
## 20   11.3     300       67 27.8  0.63253012  0.873287671     0.5932203
## 21    4.4     149       85 16.3  0.21686747  0.356164384     0.8983051
## 22   12.1     255       74 35.1  0.68072289  0.719178082     0.7118644
## 23    2.7      72       66 14.9  0.11445783  0.092465753     0.5762712
## 24   16.1     259       44 17.1  0.92168675  0.732876712     0.2033898
## 25    9.0     178       70 28.2  0.49397590  0.455479452     0.6440678
## 26    6.0     109       53 16.4  0.31325301  0.219178082     0.3559322
## 27    4.3     102       62 16.5  0.21084337  0.195205479     0.5084746
## 28   12.2     252       81 46.0  0.68674699  0.708904110     0.8305085
## 29    2.1      57       56  9.5  0.07831325  0.041095890     0.4067797
## 30    7.4     159       89 18.8  0.39759036  0.390410959     0.9661017
## 31   11.4     285       70 32.1  0.63855422  0.821917808     0.6440678
## 32   11.1     254       86 26.1  0.62048193  0.715753425     0.9152542
## 33   13.0     337       45 16.1  0.73493976  1.000000000     0.2203390
## 34    0.8      45       44  7.3  0.00000000  0.000000000     0.2033898
## 35    7.3     120       75 21.4  0.39156627  0.256849315     0.7288136
## 36    6.6     151       68 20.0  0.34939759  0.363013699     0.6101695
## 37    4.9     159       67 29.3  0.24698795  0.390410959     0.5932203
## 38    6.3     106       72 14.9  0.33132530  0.208904110     0.6779661
## 39    3.4     174       87  8.3  0.15662651  0.441780822     0.9322034
## 40   14.4     279       48 22.5  0.81927711  0.801369863     0.2711864
## 41    3.8      86       45 12.8  0.18072289  0.140410959     0.2203390
## 42   13.2     188       59 26.9  0.74698795  0.489726027     0.4576271
## 43   12.7     201       80 25.5  0.71686747  0.534246575     0.8135593
## 44    3.2     120       80 22.9  0.14457831  0.256849315     0.8135593
## 45    2.2      48       32 11.2  0.08433735  0.010273973     0.0000000
## 46    8.5     156       63 20.7  0.46385542  0.380136986     0.5254237
## 47    4.0     145       73 26.2  0.19277108  0.342465753     0.6949153
## 48    5.7      81       39  9.3  0.29518072  0.123287671     0.1186441
## 49    2.6      53       66 10.8  0.10843373  0.027397260     0.5762712
## 50    6.8     161       60 15.6  0.36144578  0.397260274     0.4745763
##     Rape_norm
## 1  0.35917313
## 2  0.96124031
## 3  0.61240310
## 4  0.31524548
## 5  0.86046512
## 6  0.81136951
## 7  0.09819121
## 8  0.21963824
## 9  0.63565891
## 10 0.47803618
## 11 0.33333333
## 12 0.17829457
## 13 0.43152455
## 14 0.35400517
## 15 0.10335917
## 16 0.27648579
## 17 0.23255814
## 18 0.38501292
## 19 0.01291990
## 20 0.52971576
## 21 0.23255814
## 22 0.71834625
## 23 0.19638243
## 24 0.25322997
## 25 0.54005168
## 26 0.23514212
## 27 0.23772610
## 28 1.00000000
## 29 0.05684755
## 30 0.29715762
## 31 0.64082687
## 32 0.48578811
## 33 0.22739018
## 34 0.00000000
## 35 0.36434109
## 36 0.32816537
## 37 0.56847545
## 38 0.19638243
## 39 0.02583979
## 40 0.39276486
## 41 0.14211886
## 42 0.50645995
## 43 0.47028424
## 44 0.40310078
## 45 0.10077519
## 46 0.34625323
## 47 0.48837209
## 48 0.05167959
## 49 0.09043928
## 50 0.21447028&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, if we wanted to summarize all of these columns, it would look like this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;USArrests %&amp;gt;% 
  summarize_all(list(mean = mean, median = median))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Murder_mean Assault_mean UrbanPop_mean Rape_mean Murder_median
## 1       7.788       170.76         65.54    21.232          7.25
##   Assault_median UrbanPop_median Rape_median
## 1            159              66        20.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, it is that easy!&lt;/p&gt;
&lt;p&gt;Now, since the implementation is fairly similar to the other scoped variables, I won’t belabor the point. Instead, I will leave you will one other useful tool from the &lt;code&gt;_all&lt;/code&gt; variants that I find helpful. Ordinarily, I prefer to work with my variable names in snake case. Luckily, the &lt;code&gt;janitor&lt;/code&gt; package provides a &lt;em&gt;great&lt;/em&gt; function, &lt;code&gt;clean_names&lt;/code&gt;, to convert column names to all kinds of formats, snake case included. However, I find that when I want to share data with people not working in R, such as my manager, she does not want to see column names in snake case. Unfortunately, as far as I know, there is not a simply function, at this point, to convert R friendly column names back to title case. To accomplish this easily, I use the &lt;code&gt;rename_all&lt;/code&gt; function. Let me know you an example with the &lt;code&gt;iris&lt;/code&gt; data set after I have converted it to snake case with &lt;code&gt;janitor::clean_names&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;iris_tbl &amp;lt;- iris %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  janitor::clean_names()

iris_tbl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 150 x 5
##    sepal_length sepal_width petal_length petal_width species
##           &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt; &amp;lt;fct&amp;gt;  
##  1          5.1         3.5          1.4         0.2 setosa 
##  2          4.9         3            1.4         0.2 setosa 
##  3          4.7         3.2          1.3         0.2 setosa 
##  4          4.6         3.1          1.5         0.2 setosa 
##  5          5           3.6          1.4         0.2 setosa 
##  6          5.4         3.9          1.7         0.4 setosa 
##  7          4.6         3.4          1.4         0.3 setosa 
##  8          5           3.4          1.5         0.2 setosa 
##  9          4.4         2.9          1.4         0.2 setosa 
## 10          4.9         3.1          1.5         0.1 setosa 
## # ... with 140 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, now the names are super R-friendly. However, we want them to be converted back to title case without the underscores. Let’s see how that can be done.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;iris_tbl %&amp;gt;% 
  rename_all(list(~stringr::str_to_title(stringr::str_replace(., &amp;quot;_&amp;quot;, &amp;quot; &amp;quot;)))) %&amp;gt;% 
  head() %&amp;gt;% 
  knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;right&#34;&gt;Sepal Length&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Sepal Width&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Petal Length&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Petal Width&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Species&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;5.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;setosa&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;4.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;setosa&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;4.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;setosa&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;4.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;setosa&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;5.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;setosa&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;5.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;setosa&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This, in my opinion, looks much nicer in a table that you are distributing outside of the R world.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The scoped verbs in the &lt;code&gt;dplyr&lt;/code&gt; package are just one more example of why this package is so useful. These functions allow you to apply other functions to your data set across numerous columns without repeating yourself and have the potential to greatly speed up your workflow and reduce the amount of typing that is required if you start to use them in your code.&lt;/p&gt;
&lt;p&gt;This post by no means covers all of the scoped verbs that are available, but rather just gives you a taste of how you implement different versions of them. If you have any questions or comments, please share them below!&lt;/p&gt;
&lt;/div&gt;
</description>
  </item>
  
<item>
  <title>Calculating quantiles for groups with dplyr::summarize and purrr::partial</title>
  <link>/2018/10/01/calculating-quantiles-for-groups-with-dplyr-summarize-and-purrr-partial/</link>
  <pubDate>Mon, 01 Oct 2018 00:00:00 +0000</pubDate>
  
<guid>/2018/10/01/calculating-quantiles-for-groups-with-dplyr-summarize-and-purrr-partial/</guid>
  <description>


&lt;p&gt;Recently, I was trying to calculate the percentiles of a set of variables within a data set grouped by another variable. However, I quickly ran into the realization that this is not very straight forward when using &lt;code&gt;dplyr&lt;/code&gt;’s &lt;code&gt;summarize&lt;/code&gt;. Before I demonstrate, let’s load the libraries that we will need.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
library(purrr)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don’t believe me when I say that it is not straight forward, go ahead and try to run the following block of code.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
  dplyr::group_by(cyl) %&amp;gt;% 
  dplyr::summarize(quants = quantile(mpg, probs = c(0.2, 0.5, 0.8)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you ran the code, you will see that it throws the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error in summarise_impl(.data, dots) : 
  Column `quants` must be length 1 (a summary value), not 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This error is telling us that the result is returning an object of length 3 (our three quantiles) when it is expecting to get only one value. A quick Google search comes up with &lt;a href=&#34;https://stackoverflow.com/questions/30488389/using-dplyr-window-functions-to-calculate-percentiles&#34;&gt;numerous&lt;/a&gt; &lt;a href=&#34;https://stackoverflow.com/questions/46935464/dplyr-to-count-means-by-group-and-then-quantiles-for-each&#34;&gt;stack&lt;/a&gt; &lt;a href=&#34;https://stackoverflow.com/questions/46177312/how-to-find-quantile-of-grouped-variable-in-dplyr&#34;&gt;overflow&lt;/a&gt; &lt;a href=&#34;https://stackoverflow.com/questions/37845915/how-to-use-quantile-with-dplyr-and-group-by&#34;&gt;questions&lt;/a&gt; and &lt;a href=&#34;https://groups.google.com/forum/#!topic/manipulatr/jEUIbQi-iuA&#34;&gt;answers&lt;/a&gt; about this. Most of these solutions revolve around using the &lt;code&gt;do&lt;/code&gt; function to calculate the quantiles on each of the groups. However, according to &lt;a href=&#34;https://community.rstudio.com/t/should-i-move-away-from-do-and-rowwise/2857/2&#34;&gt;Hadley&lt;/a&gt;, &lt;code&gt;do&lt;/code&gt; will eventually be “going away”. While there is no definite time frame on this, I try to use it as little as possible. The new recommended practice is a combination of &lt;code&gt;tidyr::nest&lt;/code&gt;, &lt;code&gt;dplyr::mutate&lt;/code&gt; and &lt;code&gt;purrr::map&lt;/code&gt; for most cases of grouping. I love this approach for most things (and it is even the accepted for one of &lt;a href=&#34;https://stackoverflow.com/questions/30488389/using-dplyr-window-functions-to-calculate-percentiles&#34;&gt;the SO questions mentioned above&lt;/a&gt;) but I worked up a new solution that I think is useful for calculating percentiles on multiple groups for any desired number of percentiles.&lt;/p&gt;
&lt;p&gt;This method uses &lt;code&gt;purrr::map&lt;/code&gt; and a &lt;a href=&#34;http://adv-r.had.co.nz/Function-operators.html&#34;&gt;Function Operator&lt;/a&gt;, &lt;a href=&#34;https://rdrr.io/cran/purrr/man/partial.html&#34;&gt;&lt;code&gt;purrr::partial&lt;/code&gt;&lt;/a&gt;, to create a list of functions that can than be applied to a data set using &lt;code&gt;dplyr::summarize_at&lt;/code&gt; and a little magic from &lt;code&gt;rlang&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s start by creating a vector of the desired percentiles to calculate. In this example, we will calculate the 20&lt;sup&gt;th&lt;/sup&gt;, 50&lt;sup&gt;th&lt;/sup&gt;, and 80&lt;sup&gt;th&lt;/sup&gt; percentiles.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p &amp;lt;- c(0.2, 0.5, 0.8)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can create a list of functions, with one for each quantile, using &lt;code&gt;purrr::map&lt;/code&gt; and &lt;code&gt;purrr::partial&lt;/code&gt;. We can also assign names to each function (useful for the output of &lt;code&gt;summarize&lt;/code&gt;) using &lt;code&gt;purrr::set_names&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p_names &amp;lt;- map_chr(p, ~paste0(.x*100, &amp;quot;%&amp;quot;))

p_funs &amp;lt;- map(p, ~partial(quantile, probs = .x, na.rm = TRUE)) %&amp;gt;% 
  set_names(nm = p_names)

p_funs&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $`20%`
## function (...) 
## quantile(probs = .x, na.rm = TRUE, ...)
## &amp;lt;environment: 0x7fcf50757430&amp;gt;
## 
## $`50%`
## function (...) 
## quantile(probs = .x, na.rm = TRUE, ...)
## &amp;lt;environment: 0x7fcf50762c30&amp;gt;
## 
## $`80%`
## function (...) 
## quantile(probs = .x, na.rm = TRUE, ...)
## &amp;lt;environment: 0x7fcf51148830&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at &lt;code&gt;p_funs&lt;/code&gt; we can see that we have a named list with each element containing a function comprised of the &lt;code&gt;quantile&lt;/code&gt; function. The beauty of this is that you can use this list in the same way you would define multiple functions in any other &lt;code&gt;summarize_at&lt;/code&gt; or &lt;code&gt;summarize_all&lt;/code&gt; functions (i.e. &lt;code&gt;funs(mean, sd)&lt;/code&gt;). The only difference is that we will now have to use the “bang-bang-bang” operator (&lt;code&gt;!!!&lt;/code&gt;) from &lt;code&gt;rlang&lt;/code&gt; (it is also exported from &lt;code&gt;dplyr&lt;/code&gt;). The final product looks like this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
  group_by(cyl) %&amp;gt;% 
  summarize_at(vars(mpg), funs(!!!p_funs))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 4
##     cyl `20%` `50%` `80%`
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     4  22.8  26    30.4
## 2     6  18.3  19.7  21  
## 3     8  13.9  15.2  16.8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I think that this provides a pretty neat way to get the desired output in a format that does not require a large amount of post calculation manipulation. In addition, it is, in my opinion, more straightforward than a lot of the &lt;code&gt;do&lt;/code&gt; methods. This method also allows for quantiles to be calculated for more than one variable, although post-processing would be necessary in that case. Here is an example.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mtcars %&amp;gt;% 
  group_by(cyl) %&amp;gt;% 
  summarize_at(vars(mpg, hp), funs(!!!p_funs)) %&amp;gt;% 
  select(cyl, contains(&amp;quot;mpg&amp;quot;), contains(&amp;quot;hp&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 7
##     cyl `mpg_20%` `mpg_50%` `mpg_80%` `hp_20%` `hp_50%` `hp_80%`
##   &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1     4      22.8      26        30.4       65      91        97
## 2     6      18.3      19.7      21        110     110       123
## 3     8      13.9      15.2      16.8      175     192.      245&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;partial&lt;/code&gt; is &lt;em&gt;yet another&lt;/em&gt; tool from the &lt;code&gt;purrr&lt;/code&gt; package that can greatly enhance your R coding abilities. While this is surely a basic application of its functionality, one can easily see how powerful this function can be.&lt;/p&gt;
</description>
  </item>
  
<item>
  <title>Create a dynamic number of UI elements in Shiny with purrr</title>
  <link>/2018/08/10/create-a-dynamic-number-of-ui-elements-in-shiny-with-purrr/</link>
  <pubDate>Fri, 10 Aug 2018 00:00:00 +0000</pubDate>
  
<guid>/2018/08/10/create-a-dynamic-number-of-ui-elements-in-shiny-with-purrr/</guid>
  <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://purrr.tidyverse.org/&#34;&gt;&lt;code&gt;purrr&lt;/code&gt;&lt;/a&gt; is an incredibly powerful package that has greatly enhanced my R programming abilities. &lt;code&gt;purrr&lt;/code&gt; has applications in pretty much any situation. One of the most useful situations, IMHO, is in the creation of a dynamic number of &lt;a href=&#34;https://shiny.rstudio.com/&#34;&gt;&lt;code&gt;shiny&lt;/code&gt;&lt;/a&gt; UI elements. This can be extremely useful if you want to be able to create a dynamic number of ui elements (whether that be inputs or outputs) based on either user selection or the data being used. This post will walk through how to create a dynamic number of plots depending on how many parameters the user selects.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;background&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Background&lt;/h1&gt;
&lt;p&gt;Before we get started, let’s load the libraries we will be using.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dataRetrieval)
library(tidyverse)
library(lubridate)
library(shiny)
library(shinyjs)
library(plotly)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data&lt;/h2&gt;
&lt;p&gt;In this post, I will be using the R package &lt;a href=&#34;https://github.com/USGS-R/dataRetrieval&#34;&gt;&lt;code&gt;dataRetrieval&lt;/code&gt;&lt;/a&gt; provided by the USGS to access their public API. If you wish to know more about how to use this package I would recommend checking out &lt;a href=&#34;https://cran.r-project.org/web/packages/dataRetrieval/vignettes/dataRetrieval.html&#34;&gt;the package’s vignette&lt;/a&gt;. The data used in this example app is daily water quality averages for three parameters (Temperature, Conductivity, and Dissolved Oxygen) measured in the Delaware River at the Ben Franklin Bridge in Philadelphia, PA. The code to pull the site info is placed at the top of the script outside of the ui and server code and looks like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# usgs site number of ben franklin bridge site
site &amp;lt;- &amp;quot;01467200&amp;quot;

site_info &amp;lt;- whatNWISdata(siteNumbers = site, service = &amp;quot;dv&amp;quot;, statCd = &amp;quot;00003&amp;quot;)

param_info &amp;lt;- site_info$parm_cd %&amp;gt;% unique() %&amp;gt;% readNWISpCode()


site_meta &amp;lt;- site_info %&amp;gt;% 
  select(site_no, station_nm, parm_cd) %&amp;gt;% 
  left_join(param_info %&amp;gt;% 
              select(parameter_cd, srsname, parameter_units), 
            by = c(&amp;quot;parm_cd&amp;quot; = &amp;quot;parameter_cd&amp;quot;)) %&amp;gt;% 
  # these are the parameters with data at this site 
  filter(parm_cd %in% c(&amp;quot;00010&amp;quot;, &amp;quot;00095&amp;quot;, &amp;quot;00300&amp;quot;))

param_choices &amp;lt;- site_meta$parm_cd
names(param_choices) &amp;lt;- site_meta$srsname&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The actual data is queried from the API using the &lt;code&gt;readNWISdv&lt;/code&gt; function and reformatted to be easy to graph inside an &lt;code&gt;eventReactive&lt;/code&gt; function at the top of the server code. This looks like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;wq_data &amp;lt;- eventReactive(input$submit, {
      req(input$parameter, input$date)
      
      raw_data &amp;lt;- readNWISdv(
        siteNumbers = site, 
        parameterCd = input$parameter,
        startDate = input$date[[1]],
        endDate = input$date[[2]]
      )
      
      output &amp;lt;- raw_data %&amp;gt;% 
        select(-contains(&amp;quot;_cd&amp;quot;)) %&amp;gt;% 
        gather(key = &amp;quot;parameter&amp;quot;, value = &amp;quot;result&amp;quot;, contains(&amp;quot;X_&amp;quot;)) %&amp;gt;% 
        mutate(parameter = str_replace_all(parameter, &amp;quot;X_|_00003&amp;quot;, &amp;quot;&amp;quot;)) %&amp;gt;% 
        left_join(site_meta, by = c(&amp;quot;parameter&amp;quot; = &amp;quot;parm_cd&amp;quot;, &amp;quot;site_no&amp;quot;)) 
      
      return(output)
    })&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;plotting-function&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Plotting function&lt;/h2&gt;
&lt;p&gt;Since the focus of this post is how to generate multiple plots and the data format after basic manipulation is the same for all three parameters, I have defined my plot generation as a function named &lt;code&gt;wq_plotly()&lt;/code&gt; outside of the server code. This functions looks like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;wq_plotly &amp;lt;- function(data){
  data %&amp;gt;%
    plot_ly(
      x = ~Date,
      y = ~result,
      type = &amp;quot;scatter&amp;quot;,
      mode = &amp;quot;lines+markers&amp;quot;,
      marker = list(
        size = 4,
        color = &amp;quot;blue&amp;quot;
      ),
      line = list(
        color = &amp;quot;blue&amp;quot;
      ),
      hoverinfo = &amp;quot;text&amp;quot;,
      text = ~paste(
        &amp;quot;Site:&amp;quot;, station_nm,
        &amp;quot;&amp;lt;br&amp;gt;Parameter:&amp;quot;, srsname,
        &amp;quot;&amp;lt;br&amp;gt;Date Time:&amp;quot;, format(Date),
        &amp;quot;&amp;lt;br&amp;gt;Result:&amp;quot;, result,
        &amp;quot;&amp;lt;br&amp;gt;Units:&amp;quot;, parameter_units
      )
    ) %&amp;gt;%
    layout(
      title = paste(
        unique(data$station_nm), &amp;quot;&amp;lt;br&amp;gt;&amp;quot;, 
        unique(data$srsname), 
        paste0(&amp;quot;(&amp;quot;, unique(data$parameter_units), &amp;quot;)&amp;quot;)
      ),
      titlefont = list(
        size = 10
      ),
      xaxis = list(
        title = &amp;quot;&amp;quot;
      ),
      yaxis = list(
        title = &amp;quot;&amp;quot;
      ),
      margin = list(
        t = 40
      )
    )
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;ui&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;UI&lt;/h1&gt;
&lt;p&gt;So the first part of the app is the ui code. This part is actually somewhat straightforward because all of the magic is gonna happen in our server code. We have to define our inputs for which parameters to graph (named &lt;code&gt;input$parameter&lt;/code&gt;) and the desired date range (named &lt;code&gt;input$date&lt;/code&gt;) and create an &lt;code&gt;actionButton&lt;/code&gt; so that the user controls when new graphs are generated (my personal preference). I create these all within a single &lt;code&gt;fluidRow&lt;/code&gt; with each in its own &lt;code&gt;column&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After that, I create a new &lt;code&gt;fluidRow&lt;/code&gt; and simply have a &lt;code&gt;uiOutput&lt;/code&gt; (with an id of &lt;code&gt;graphs_ui&lt;/code&gt;) in it. This &lt;code&gt;uiOutput&lt;/code&gt; will be created in our server code and contain all of the ui elements for our plots.&lt;/p&gt;
&lt;p&gt;Here is the full ui code:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ui &amp;lt;- shinyUI(
  fluidPage(
    tags$head(
      tags$style(HTML(&amp;#39;.shiny-input-container{margin-top: 20px;}&amp;#39;))
    ),
    div(
      fluidRow(
        column(
          4, 
          selectInput(
            inputId = &amp;quot;parameter&amp;quot;,
            label = &amp;quot;Select Parameter(s):&amp;quot;,
            choices = param_choices,
            multiple = TRUE
          )
        ),
        column(
          4,
          dateRangeInput(
            inputId = &amp;quot;date&amp;quot;,
            label = &amp;quot;Select Date Range:&amp;quot;,
            start = Sys.Date() - days(31),
            end = Sys.Date()
          )
        ),
        column(
          4, 
          actionButton(
            inputId = &amp;quot;submit&amp;quot;,
            label = &amp;quot;Apply Changes!&amp;quot;,
            style = &amp;quot;margin:40px;&amp;quot;
          )
        )
      ),
      fluidRow(
        div(
          id = &amp;quot;plot-container&amp;quot;,
          uiOutput(
            outputId = &amp;quot;graphs_ui&amp;quot;
          )
        )
      )
    )
  )
)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;server&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Server&lt;/h1&gt;
&lt;p&gt;Now for the fun! The first part of the server code, which was shown above, is the &lt;code&gt;wq_data&lt;/code&gt; reactive expression to query our data set. The next part involves generating a reactive object that contains a list of our graphs (a vector would work too). This is important because it is what will be used to generate the different inputs. Since I defined my graphing function above, I can call that with a combination of &lt;code&gt;dplyr::group_by&lt;/code&gt;, &lt;code&gt;tidyr::nest&lt;/code&gt;, &lt;code&gt;dplyr::mutate&lt;/code&gt;, &lt;code&gt;purrr::map&lt;/code&gt;, and &lt;code&gt;dplyr::pull&lt;/code&gt;. This combination allows us to create unique graphs for each parameter and store them in a single list. The code looks like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;graphs &amp;lt;- eventReactive(input$submit, {
  req(wq_data())
      
  wq_data() %&amp;gt;% 
    group_by(parameter) %&amp;gt;% 
    nest() %&amp;gt;% 
    mutate(
       graphs = map(data, wq_plotly) 
    ) %&amp;gt;% 
    arrange(parameter) %&amp;gt;% 
    pull(graphs)
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note that I have only tested this on &lt;a href=&#34;https://plot.ly/r/&#34;&gt;&lt;code&gt;plotly&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://ggplot2.tidyverse.org/&#34;&gt;&lt;code&gt;ggplot2&lt;/code&gt;&lt;/a&gt;, and base graphics. This method only works with &lt;code&gt;plotly&lt;/code&gt; and &lt;code&gt;ggplot2&lt;/code&gt;. It does not work with base graphics because base plots cannot be saved as objects.&lt;/p&gt;
&lt;p&gt;Now that we have our list of graphs, we need to create our outputs. However, since we are giving the user the ability to choose how many parameters they want to create graphs for, &lt;em&gt;how do we know&lt;/em&gt; how many outputs to create? With &lt;code&gt;purrr&lt;/code&gt; and our list of graphs, &lt;strong&gt;we don’t need to know&lt;/strong&gt; how many outputs need to be created. By iterating over our list of graphs with &lt;code&gt;iwalk&lt;/code&gt; we can create as many outputs as there are graphs.&lt;/p&gt;
&lt;p&gt;In this case, we want to use &lt;code&gt;purrr::iwalk&lt;/code&gt; (which is a variant of &lt;code&gt;walk&lt;/code&gt;) because we want to use both the graph and its index. Using &lt;code&gt;iwalk(x, ...)&lt;/code&gt; is the same as using &lt;code&gt;walk2(x, seq_along(x), ...)&lt;/code&gt;. We use &lt;code&gt;walk&lt;/code&gt; instead of &lt;code&gt;map&lt;/code&gt; because we are not returning anything from the overall iteration, but rather only using it for its side effects. Using &lt;code&gt;walk&lt;/code&gt; instead of &lt;code&gt;map&lt;/code&gt; is similar to using an &lt;code&gt;observe&lt;/code&gt; function instead of a &lt;code&gt;reactive&lt;/code&gt; function. To further connect the comparison, we will use our &lt;code&gt;iwalk&lt;/code&gt; function inside of an &lt;code&gt;observeEvent&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;Here is what the output generation looks like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;observeEvent(input$submit, {
  req(graphs())
      
  iwalk(graphs(), ~{
    output_name &amp;lt;- paste0(&amp;quot;plot_&amp;quot;, .y)
    output[[output_name]] &amp;lt;- renderPlotly(.x)
  })
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two simple pieces to our &lt;code&gt;iwalk&lt;/code&gt; function. First, we define a unique &lt;code&gt;outputId&lt;/code&gt; using the index of the plot in our list. Then using that &lt;code&gt;outputId&lt;/code&gt; we can render our plotly object.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; defining an output using &lt;code&gt;output[[&amp;quot;my_output_id&amp;quot;]]&lt;/code&gt; is the same as defining it as &lt;code&gt;output$my_output_id&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, the last step of the server code is to create the ui elements! Remember, in our ui code, we defined the &lt;code&gt;uiOutput&lt;/code&gt; for our graphs with an id of &lt;code&gt;graphs_ui&lt;/code&gt;. So now, we will use &lt;code&gt;renderUI&lt;/code&gt; and &lt;code&gt;purrr::imap&lt;/code&gt; to create our ui elements. Since &lt;code&gt;render*&lt;/code&gt; functions are similar to &lt;code&gt;reactive&lt;/code&gt; functions, in that they return their output, we use &lt;code&gt;imap&lt;/code&gt; rather than &lt;code&gt;iwalk&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is what our ui generation looks like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;output$graphs_ui &amp;lt;- renderUI({
  req(graphs())
      
  plots_list &amp;lt;- imap(graphs(), ~{
    tagList(
      plotlyOutput(
        outputId = paste0(&amp;quot;plot_&amp;quot;, .y)
      ),
      br()
    )
        
  })
      
  tagList(plots_list)
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, we use the index of our plot list again to call each individual plot &lt;code&gt;outputId&lt;/code&gt;. It is important to notice the &lt;code&gt;tagList(plots_list)&lt;/code&gt; call at the end of the &lt;code&gt;renderUI&lt;/code&gt; function. Since the output of &lt;code&gt;imap&lt;/code&gt; is a list, &lt;code&gt;plots_list&lt;/code&gt; is a list of ui elements and is not valid to be entered directly into the UI code. &lt;code&gt;tagList&lt;/code&gt; takes care of this for us and combines multiple ui elements into one.&lt;/p&gt;
&lt;p&gt;Combining all of these elements, our final shiny app looks like this:&lt;/p&gt;
&lt;center&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/dynamic-ui-elements/dynamic-graphs.gif&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Being able to create a dynamic number of ui elements, whether they are inputs or outputs, is an incredibly powerful tool when trying to scale your shiny apps! The method shown here was applied to creating a dynamic number of graphs based on the users input, but it is certainly not limited to that! You can see an example of how to apply this to creating &lt;code&gt;textInput&lt;/code&gt; and &lt;code&gt;numericInput&lt;/code&gt; dynamically based on column names of an uploaded dataset in this &lt;a href=&#34;https://community.rstudio.com/t/creating-multiple-numeric-input-according-to-the-variables-of-an-uploaded-dataset/12293&#34;&gt;RStudio Community thread&lt;/a&gt;. Learning and using &lt;code&gt;purrr&lt;/code&gt; can &lt;strong&gt;&lt;em&gt;dramatically&lt;/em&gt;&lt;/strong&gt; increase your capabilities within general R programming and building shiny applications!&lt;/p&gt;
&lt;p&gt;Finally, the full code for the shiny app looks like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dataRetrieval)
library(tidyverse)
library(lubridate)
library(shiny)
library(shinyjs)
library(plotly)


# usgs site number of ben franklin bridge site
site &amp;lt;- &amp;quot;01467200&amp;quot;

site_info &amp;lt;- whatNWISdata(siteNumbers = site, service = &amp;quot;dv&amp;quot;, statCd = &amp;quot;00003&amp;quot;)

param_info &amp;lt;- site_info$parm_cd %&amp;gt;% unique() %&amp;gt;% readNWISpCode()


site_meta &amp;lt;- site_info %&amp;gt;% 
  select(site_no, station_nm, parm_cd) %&amp;gt;% 
  left_join(param_info %&amp;gt;% 
              select(parameter_cd, srsname, parameter_units), 
            by = c(&amp;quot;parm_cd&amp;quot; = &amp;quot;parameter_cd&amp;quot;)) %&amp;gt;% 
  filter(parm_cd %in% c(&amp;quot;00010&amp;quot;, &amp;quot;00095&amp;quot;, &amp;quot;00300&amp;quot;))

param_choices &amp;lt;- site_meta$parm_cd
names(param_choices) &amp;lt;- site_meta$srsname

wq_plotly &amp;lt;- function(data){
  data %&amp;gt;%
    plot_ly(
      x = ~Date,
      y = ~result,
      type = &amp;quot;scatter&amp;quot;,
      mode = &amp;quot;lines+markers&amp;quot;,
      marker = list(
        size = 4,
        color = &amp;quot;blue&amp;quot;
      ),
      line = list(
        color = &amp;quot;blue&amp;quot;
      ),
      hoverinfo = &amp;quot;text&amp;quot;,
      text = ~paste(
        &amp;quot;Site:&amp;quot;, station_nm,
        &amp;quot;&amp;lt;br&amp;gt;Parameter:&amp;quot;, srsname,
        &amp;quot;&amp;lt;br&amp;gt;Date Time:&amp;quot;, format(Date),
        &amp;quot;&amp;lt;br&amp;gt;Result:&amp;quot;, result,
        &amp;quot;&amp;lt;br&amp;gt;Units:&amp;quot;, parameter_units
      )
    ) %&amp;gt;%
    layout(
      title = paste(
        unique(data$station_nm), &amp;quot;&amp;lt;br&amp;gt;&amp;quot;, 
        unique(data$srsname), 
        paste0(&amp;quot;(&amp;quot;, unique(data$parameter_units), &amp;quot;)&amp;quot;)
      ),
      titlefont = list(
        size = 10
      ),
      xaxis = list(
        title = &amp;quot;&amp;quot;
      ),
      yaxis = list(
        title = &amp;quot;&amp;quot;
      ),
      margin = list(
        t = 40
      )
    )
}


ui &amp;lt;- shinyUI(
  fluidPage(
    tags$head(
      tags$style(HTML(&amp;#39;.shiny-input-container{margin-top: 20px;}&amp;#39;))
    ),
    div(
      fluidRow(
        column(
          4, 
          selectInput(
            inputId = &amp;quot;parameter&amp;quot;,
            label = &amp;quot;Select Parameter(s):&amp;quot;,
            choices = param_choices,
            multiple = TRUE
          )
        ),
        column(
          4,
          dateRangeInput(
            inputId = &amp;quot;date&amp;quot;,
            label = &amp;quot;Select Date Range:&amp;quot;,
            start = Sys.Date() - days(31),
            end = Sys.Date()
          )
        ),
        column(
          4, 
          actionButton(
            inputId = &amp;quot;submit&amp;quot;,
            label = &amp;quot;Apply Changes!&amp;quot;,
            style = &amp;quot;margin:40px;&amp;quot;
          )
        )
      ),
      fluidRow(
        div(
          id = &amp;quot;plot-container&amp;quot;,
          uiOutput(
            outputId = &amp;quot;graphs_ui&amp;quot;
          )
        )
      )
    )
  )
)


server &amp;lt;- shinyServer(
  function(input, output, session){
    session$onSessionEnded(stopApp)
    
    # query data from USGS API
    wq_data &amp;lt;- eventReactive(input$submit, {
      req(input$parameter, input$date)
      
      raw_data &amp;lt;- readNWISdv(
        siteNumbers = site, 
        parameterCd = input$parameter,
        startDate = input$date[[1]],
        endDate = input$date[[2]]
      )
      
      output &amp;lt;- raw_data %&amp;gt;% 
        select(-contains(&amp;quot;_cd&amp;quot;)) %&amp;gt;% 
        gather(key = &amp;quot;parameter&amp;quot;, value = &amp;quot;result&amp;quot;, contains(&amp;quot;X_&amp;quot;)) %&amp;gt;% 
        mutate(parameter = str_replace_all(parameter, &amp;quot;X_|_00003&amp;quot;, &amp;quot;&amp;quot;)) %&amp;gt;% 
        left_join(site_meta, by = c(&amp;quot;parameter&amp;quot; = &amp;quot;parm_cd&amp;quot;, &amp;quot;site_no&amp;quot;)) 
      
      return(output)
    })
    
    # create a list of graphs - with one for each parameter selected
    graphs &amp;lt;- eventReactive(input$submit, {
      req(wq_data())
      
      wq_data() %&amp;gt;% 
        group_by(parameter) %&amp;gt;% 
        nest() %&amp;gt;% 
        mutate(
          graphs = map(data, wq_plotly) 
        ) %&amp;gt;% 
        arrange(parameter) %&amp;gt;% 
        pull(graphs)
    })
    
    # use purrr::iwalk to create a dynamic number of outputs
    observeEvent(input$submit, {
      req(graphs())
      
      iwalk(graphs(), ~{
        output_name &amp;lt;- paste0(&amp;quot;plot_&amp;quot;, .y)
        output[[output_name]] &amp;lt;- renderPlotly(.x)
      })
    })
    
    # use renderUI to create a dynamic number of output ui elements
    output$graphs_ui &amp;lt;- renderUI({
      req(graphs())
      
      plots_list &amp;lt;- imap(graphs(), ~{
        tagList(
          plotlyOutput(
            outputId = paste0(&amp;quot;plot_&amp;quot;, .y)
          ),
          br()
        )
        
      })
      
      tagList(plots_list)
    })
    
  }
)


shinyApp(ui = ui, server = server)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
  </item>
  
<item>
  <title>PCA in a tidy(verse) framework</title>
  <link>/2018/02/01/pca-in-a-tidy-verse-framework/</link>
  <pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate>
  
<guid>/2018/02/01/pca-in-a-tidy-verse-framework/</guid>
  <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The other day, a &lt;a href=&#34;https://community.rstudio.com/t/tidyverse-solutions-for-factor-analysis-principal-component-analysis/4504&#34;&gt;question&lt;/a&gt; was posted on &lt;a href=&#34;https://community.rstudio.com/&#34;&gt;RStudio Community&lt;/a&gt; about performing Principal Component Analysis (PCA) in a &lt;a href=&#34;https://www.tidyverse.org/&#34;&gt;tidyverse&lt;/a&gt; workflow. Conveniently, I had literally just worked through this process the day before and was able to post an &lt;a href=&#34;https://community.rstudio.com/t/tidyverse-solutions-for-factor-analysis-principal-component-analysis/4504/2&#34;&gt;answer&lt;/a&gt;. While most questions and answers are good as they are on forum sites, I thought this one might be worth exploring a little more since using the tidyverse framework makes PCA much easier, in my opinion.&lt;/p&gt;
&lt;p&gt;PCA is a multi-variate statistical technique for dimension reduction. Essentially, it allows you to take a data set that has n continuous variables and relate them through n orthogonal dimensions. This is a method of unsupervised learning that allows you to better understand the variability in the data set and how different variables are related. While there are the same number of principal components created as there are variables (assuming you have more observations than variables-but that is another issue), each principal component explains the maximum possible variation in the data conditional on it being orthogonal, or perpendicular, to the previous principal components.&lt;/p&gt;
&lt;p&gt;In my answer, I used the &lt;code&gt;iris&lt;/code&gt; data set to demonstrate how PCA can be done in the tidyverse workflow. For this post, I will be using the &lt;code&gt;USArrests&lt;/code&gt; data set that was used in &lt;a href=&#34;http://www-bcf.usc.edu/~gareth/ISL/index.html&#34;&gt;An Introduction to Statistical Thinking&lt;/a&gt; by Gareth James et. al. In this book, they work through a PCA and focus on the statistics and explanations behind PCA. This is how I learned how to do PCA and would highly recommend it if you are unfamiliar with the topic. In this blog post, my focus will be more on implementing the PCA in the tidyverse framework. Another nice walkthough of PCA with this dataset that is online can be found at &lt;a href=&#34;http://uc-r.github.io/pca&#34;&gt;University of Cincinnati’s R blog&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;exploring-the-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Exploring the data&lt;/h1&gt;
&lt;p&gt;Before we dive in to the analysis, we want to explore our data set and become familiar with it.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(broom)
library(knitr)
library(ggfortify)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;USArrests %&amp;gt;% head() %&amp;gt;% knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Murder&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Assault&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;UrbanPop&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Rape&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Alabama&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;13.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;236&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;58&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Alaska&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;263&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;44.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Arizona&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;294&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;80&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;31.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Arkansas&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;190&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;50&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;19.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;California&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;276&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;91&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;40.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Colorado&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;204&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;78&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;38.7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Looking at the first 6 rows using the &lt;code&gt;head()&lt;/code&gt; function, we can see that each row is a state and and each column is a variable. Looking at &lt;code&gt;?USArrests&lt;/code&gt;, we can see that the column descriptions are as follows:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Murder - the number of murder arrests per 100,000 people in a given state&lt;/li&gt;
&lt;li&gt;Assault - the number of assault arrests per 100,000 people in a given state&lt;/li&gt;
&lt;li&gt;UrbanPop - a numeric percentage of the urban population per state (i.e. the percentage of the state’s population that lives in cities)&lt;/li&gt;
&lt;li&gt;Rape - the number of rape arrests per 100,000 people in a given state&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now, that we see how the data set is set up, let’s try to visualize the data as it is. Before we do that, let’s convert the data set to a &lt;code&gt;tibble&lt;/code&gt;. Since tibbles do not support rownames, we will have to convert them to their own column with &lt;code&gt;rownames_to_column&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;us_arrests &amp;lt;- USArrests %&amp;gt;% 
  rownames_to_column(var = &amp;quot;state&amp;quot;) %&amp;gt;% 
  # I prefer column names to be all lowercase so I am going to change them here
  rename_all(tolower) %&amp;gt;% 
  as_tibble()

us_arrests&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 50 x 5
##    state       murder assault urbanpop  rape
##    &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;   &amp;lt;int&amp;gt;    &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;
##  1 Alabama      13.2      236       58  21.2
##  2 Alaska       10.0      263       48  44.5
##  3 Arizona       8.10     294       80  31.0
##  4 Arkansas      8.80     190       50  19.5
##  5 California    9.00     276       91  40.6
##  6 Colorado      7.90     204       78  38.7
##  7 Connecticut   3.30     110       77  11.1
##  8 Delaware      5.90     238       72  15.8
##  9 Florida      15.4      335       80  31.9
## 10 Georgia      17.4      211       60  25.8
## # ... with 40 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s take a look at murder arrest rates in each of the stats.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;us_arrests %&amp;gt;% 
  mutate(state = factor(state), 
         state = fct_reorder(state, murder) %&amp;gt;% fct_rev()) %&amp;gt;% 
  ggplot(aes(state, murder)) + 
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.4)) +
  labs(y = &amp;quot;Murder Arrest Rate per 100,000 people&amp;quot;,
       x = &amp;quot;State&amp;quot;,
       title = &amp;quot;Murder rate in each state of the USA&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-02-01-pca-in-a-tidy-verse-framework_files/figure-html/murder-bar-plot-1.png&#34; width=&#34;768&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;You can see that Georgia has the highest murder rate, followed by Mississippi, Louisiana, and Florida Let’s try one more.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;us_arrests %&amp;gt;% 
  gather(key = crime, value = rate, c(murder, assault, rape)) %&amp;gt;% 
  ggplot(aes(urbanpop, rate, color = crime)) + 
  facet_wrap(~crime, scales = &amp;quot;free_y&amp;quot;, ncol = 1) +
  geom_point() + 
  geom_smooth(se = FALSE, method = &amp;quot;lm&amp;quot;) +
  theme_bw() + 
  labs(x = &amp;quot;Percentage Urban Population&amp;quot;,
       y = &amp;quot;Arrest Rate per 100,000 people&amp;quot;,
       title = &amp;quot;Arrest rate vs percentage urban population&amp;quot;) +
  theme(legend.title = element_blank(),
        legend.position = &amp;quot;bottom&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-02-01-pca-in-a-tidy-verse-framework_files/figure-html/tidy-us-arrests-plot-1.png&#34; width=&#34;768&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This figure is a slightly more informative than the last one. In this figure, each crime rate is plotted against percentage urban population. Simple linear models are fit for each of the different crime types to see if any pattern can be seen in the data. There appears to be an increase in assault arrests as urban population grows, however, there is &lt;em&gt;a lot&lt;/em&gt; of variability around the line of best fit. Rape arrest rates follow the linear model much closer than the others but there is still a lot of variability. On the other hand, murder arrest rates seem to be unchanged based on urban population.&lt;/p&gt;
&lt;p&gt;Now we could certainly do correlations, multiple linear regressions, or fit other types of models and would likely gain some useful insights, but instead let’s focus on the PCA.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;pca-in-the-tidyverse-framework&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;PCA in the tidyverse framework&lt;/h1&gt;
&lt;p&gt;Now, when I first fit PCA models in R, I found myself with an unmanageable number of variables and to track and maintain. This can make the process overwhelming and can make you lose track of information. Luckily, using the &lt;code&gt;tidyverse&lt;/code&gt; and the &lt;code&gt;broom&lt;/code&gt; package, we can solve these issues much more easily. In order to run the model in the tidyverse framework, we will use the &lt;code&gt;nest()&lt;/code&gt; function along with the &lt;code&gt;mutate&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; combo to operate on the nested columns.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;us_arrests_pca &amp;lt;- us_arrests %&amp;gt;% 
  nest() %&amp;gt;% 
  mutate(pca = map(data, ~ prcomp(.x %&amp;gt;% select(-state), 
                                  center = TRUE, scale = TRUE)),
         pca_aug = map2(pca, data, ~augment(.x, data = .y)))

us_arrests_pca&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 3
##   data              pca          pca_aug               
##   &amp;lt;list&amp;gt;            &amp;lt;list&amp;gt;       &amp;lt;list&amp;gt;                
## 1 &amp;lt;tibble [50 x 5]&amp;gt; &amp;lt;S3: prcomp&amp;gt; &amp;lt;data.frame [50 x 10]&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, we now have a tibble with one row and three columns. The first is our original data set, the second is the &lt;code&gt;prcomp&lt;/code&gt; object and the third is a data frame containing the principal component values for each observation. Now we have everything we need to evaluate the results of the model. First, it is important to look at how much variance is explained by each principal component. This will tell you how many of the components you need to look at when analyzing the results. To do this, you can use the data in the &lt;code&gt;pca_aug&lt;/code&gt; column of our &lt;code&gt;us_arrests_pca&lt;/code&gt; tibble along with some &lt;code&gt;dplyr&lt;/code&gt; functions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;var_exp &amp;lt;- us_arrests_pca %&amp;gt;% 
  unnest(pca_aug) %&amp;gt;% 
  summarize_at(.vars = vars(contains(&amp;quot;PC&amp;quot;)), .funs = funs(var)) %&amp;gt;% 
  gather(key = pc, value = variance) %&amp;gt;% 
  mutate(var_exp = variance/sum(variance),
         cum_var_exp = cumsum(var_exp),
         pc = str_replace(pc, &amp;quot;.fitted&amp;quot;, &amp;quot;&amp;quot;))

var_exp&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 x 4
##   pc    variance var_exp cum_var_exp
##   &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
## 1 PC1      2.48   0.620        0.620
## 2 PC2      0.990  0.247        0.868
## 3 PC3      0.357  0.0891       0.957
## 4 PC4      0.173  0.0434       1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that the first principal component explains 62% of the variation and that the second principal component explains 25% of the remaining variation. Together, we can see that they explain 87% of the variance in the data set. As a general rule of thumb, you want to look at enough principal components to explain ~90% of your data’s variability.&lt;/p&gt;
&lt;p&gt;Another way of assessing this is to plot the variance explained and the cumulative variance explained and look for the “elbow” in the graph. You can do that like this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;var_exp %&amp;gt;% 
  rename(
    `Variance Explained` = var_exp,
    `Cumulative Variance Explained` = cum_var_exp
  ) %&amp;gt;% 
  gather(key = key, value = value, `Variance Explained`:`Cumulative Variance Explained`) %&amp;gt;% 
  ggplot(aes(pc, value, group = key)) + 
  geom_point() + 
  geom_line() + 
  facet_wrap(~key, scales = &amp;quot;free_y&amp;quot;) +
  theme_bw() +
  lims(y = c(0, 1)) +
  labs(y = &amp;quot;Variance&amp;quot;,
       title = &amp;quot;Variance explained by each principal component&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-02-01-pca-in-a-tidy-verse-framework_files/figure-html/var-exp-graph-1.png&#34; width=&#34;768&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Since the majority of the variance is explained by the first two principal components, let’s plot them against each other. Luckily, this is made easy by the &lt;code&gt;ggplot2&lt;/code&gt; and &lt;code&gt;ggfortify&lt;/code&gt; packages which gives an &lt;code&gt;autoplot&lt;/code&gt; method for prcomp objects. Conveniently, we still have our &lt;code&gt;prcomp&lt;/code&gt; object stored in the our &lt;code&gt;us_arrests_pca&lt;/code&gt; tibble along with our original data. This is important as the original data is needed to add labels and/or colors to your ggplot based on discrete variables not included in the PCA. Using the same &lt;code&gt;mutate&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; combo as before, along with the handy &lt;code&gt;dplyr::pull&lt;/code&gt; function, we can plot this graph. &lt;code&gt;autoplot.prcomp()&lt;/code&gt; can take any arguments that can be passed to &lt;code&gt;ggbiplot()&lt;/code&gt;, so to see all of your options use &lt;code&gt;?ggbiplot&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;us_arrests_pca %&amp;gt;%
  mutate(
    pca_graph = map2(
      .x = pca,
      .y = data,
      ~ autoplot(.x, loadings = TRUE, loadings.label = TRUE,
                 loadings.label.repel = TRUE,
                 data = .y, label = TRUE,
                 label.label = &amp;quot;state&amp;quot;,
                 label.repel = TRUE) +
        theme_bw() +
        labs(x = &amp;quot;Principal Component 1&amp;quot;,
             y = &amp;quot;Principal Component 2&amp;quot;,
             title = &amp;quot;First two principal components of PCA on USArrests dataset&amp;quot;)
    )
  ) %&amp;gt;%
  pull(pca_graph)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-02-01-pca-in-a-tidy-verse-framework_files/figure-html/pca-plot-1.png&#34; width=&#34;960&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;If you notice the &lt;code&gt;[[1]]&lt;/code&gt; above the graph, this method would automatically print each graph in the &lt;code&gt;pca_graph&lt;/code&gt; column. This means that if you fit multiple pca graphs onto a grouped data set then this would automatically print all of the figures for you in one command. Another important thing to notice is the the &lt;code&gt;autoplot()&lt;/code&gt; function simply returns a &lt;code&gt;gg&lt;/code&gt; object and that can be extended just like any other &lt;code&gt;ggplot&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Looking at this figure, we are getting a lot more information about how these variables are related. For example, we can see that murder, rape, and assault arrest rates all have similar values alone the first principal component, which indicates that they are correlated with one another. We may have been able to figure that out using more basic methods, but this method allows us to see it in one figure. In addition, we are able to see how each of the observations in the data (i.e. states) relates to the variables. For example, California is characterized by high arrest rates (1st principal component) and high urban population (2nd principal component).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;PCA can provide an analysis with a lot of information about their data set and can give valuable insights into potentially unseen relationships between the observations and the variables. By performing this analysis in the tidyverse framework, we can easily extend this model by using the modelling capabilities of the tidyverse. You can see some of these &lt;a href=&#34;http://r4ds.had.co.nz/many-models.html&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;http://www.business-science.io/code-tools/2017/10/24/demo_week_timetk.html&#34;&gt;here&lt;/a&gt;. I believe that this framework allows for much more flexibility in your analysis and how you use the data from the model, which will enable you to gather more from your data in a faster and convenient way.&lt;/p&gt;
&lt;p&gt;Please let me know what you think of performing PCA in the tidyverse framework!&lt;/p&gt;
&lt;/div&gt;
</description>
  </item>
  
<item>
  <title>Creating, Writing, Querying, and Modifying SQL Database from R using odbc, dbplyr, and DBI</title>
  <link>/2017/08/26/sql-management-in-r/</link>
  <pubDate>Sat, 26 Aug 2017 00:00:00 +0000</pubDate>
  
<guid>/2017/08/26/sql-management-in-r/</guid>
  <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Recently, I have been building shiny apps for work. The app that I am currently working on is an interface to a database for storing information about laboratory samples being collected. In addition to building the shiny app for my coworkers to interact with the database, I also was tasked with creating and building the database. I have never build a SQL database from scratch, but luckily the &lt;a href=&#34;https://github.com/rstats-db/odbc&#34;&gt;odbc&lt;/a&gt; and the &lt;a href=&#34;https://github.com/rstats-db/DBI&#34;&gt;DBI&lt;/a&gt; packages make it fairly straight foreward.&lt;/p&gt;
&lt;p&gt;Let’s start by loading in the packages that we will need.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(DBI)
library(odbc)
library(RSQLite)
library(tidyverse)
library(magrittr)
library(dbplyr)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;connecting-to-the-database&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Connecting to the Database&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;dbConnect&lt;/code&gt; function from the &lt;code&gt;DBI&lt;/code&gt; package allows us to create a SQLite database directly from R. SQLite databases are saved as files in the current working directory with this method. As described in the &lt;code&gt;RSQLite&lt;/code&gt; packge vignette, if you simply want to use a temporary database, you can create either an on-disk database or an in-memory database with this same method. For this example, we will create a new SQLite in-memory database&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;con &amp;lt;- dbConnect(RSQLite::SQLite(), &amp;quot;:memory:&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Currently, our database is empty, as can be seen if we use the &lt;code&gt;dbListTables&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dbListTables(con)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## character(0)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;writing-tables-to-database&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Writing Tables to database&lt;/h1&gt;
&lt;p&gt;To add data to this database we will use the &lt;code&gt;dbWriteTable&lt;/code&gt; function. First, let’s load in two common datasets, &lt;code&gt;mtcars&lt;/code&gt; and &lt;code&gt;diamonds&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(&amp;quot;mtcars&amp;quot;)
data(&amp;quot;diamonds&amp;quot;)

mtcars %&amp;lt;&amp;gt;% 
  rownames_to_column()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have these two data sets loaded into the session, lets write them into the database.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dbWriteTable(con, &amp;quot;cars&amp;quot;, mtcars)
dbWriteTable(con, &amp;quot;diamonds&amp;quot;, diamonds)

dbListTables(con)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;cars&amp;quot;     &amp;quot;diamonds&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;query-the-database&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Query the Database&lt;/h1&gt;
&lt;p&gt;There are several ways that we can query the tables in this database. We can read in the entire table using the &lt;code&gt;dbReadTable&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dbReadTable(con, &amp;quot;cars&amp;quot;) %&amp;gt;%
  head(10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##              rowname  mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## 1          Mazda RX4 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
## 2      Mazda RX4 Wag 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
## 3         Datsun 710 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## 4     Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
## 5  Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
## 6            Valiant 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
## 7         Duster 360 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
## 8          Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
## 9           Merc 230 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
## 10          Merc 280 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively, we can write out a full sql query using the &lt;code&gt;dbGetQuery&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dbGetQuery(con, &amp;quot;select * from cars&amp;quot;) %&amp;gt;%
  head(10) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##              rowname  mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## 1          Mazda RX4 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
## 2      Mazda RX4 Wag 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
## 3         Datsun 710 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## 4     Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
## 5  Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
## 6            Valiant 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
## 7         Duster 360 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
## 8          Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
## 9           Merc 230 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
## 10          Merc 280 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use the &lt;code&gt;microbenchmark&lt;/code&gt; package to determine which of these methods is faster. We will measure the time for the diamonds data set as that has nearly 54,000 observations, as opposed to the 32 in the mtcars dataset.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;microbenchmark::microbenchmark(
  read_table = dbReadTable(con, &amp;quot;diamonds&amp;quot;),
  query = dbGetQuery(con, &amp;quot;select * from diamonds&amp;quot;)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Unit: milliseconds
##        expr      min       lq     mean   median       uq      max neval
##  read_table 91.36283 94.55963 115.4623 98.51866 150.1218 175.2671   100
##       query 90.61233 93.50576 111.0308 98.11973 113.0769 181.2567   100&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It looks like the &lt;code&gt;dbReadTable&lt;/code&gt; method is slightly faster than a full query. However, the real benefit to using &lt;code&gt;dbGetQuery&lt;/code&gt; is the ability to write much more complex sql queries. For example, if we want to subset the data, we are able to.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;query &amp;lt;- paste(&amp;quot;select carat, cut, clarity, color, price from diamonds&amp;quot;,
               &amp;quot;where carat &amp;gt; 1 and cut = &amp;#39;Ideal&amp;#39;&amp;quot;)
dbGetQuery(con, query) %&amp;gt;%
  as.tibble()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5,662 x 5
##    carat   cut clarity color price
##    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;
##  1  1.01 Ideal      I1     I  2844
##  2  1.02 Ideal     SI2     H  2856
##  3  1.02 Ideal      I1     I  2872
##  4  1.02 Ideal     SI2     J  2879
##  5  1.01 Ideal      I1     I  2896
##  6  1.02 Ideal      I1     I  2925
##  7  1.14 Ideal     SI1     J  3045
##  8  1.02 Ideal     SI2     H  3142
##  9  1.06 Ideal     SI2     I  3146
## 10  1.02 Ideal     VS2     I  3148
## # ... with 5,652 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This particular query returned just over 10% of the total data with 5,662 rows matching the conditions set. This feature is extremely important when dealing with database that house extremely large amounts of data. Having to query full tables would be extemely unfeasible in most situations.&lt;/p&gt;
&lt;p&gt;In addition to writing more complex sql queries, the &lt;code&gt;dbplyr&lt;/code&gt; package allows for R users to avoid having to write queries at all. This package allows users to create a reference to the sql table and interact with it using typical &lt;code&gt;dplyr&lt;/code&gt; verbs. We can recreate the query above using this method. First we will use the &lt;code&gt;tbl&lt;/code&gt; function to create the reference to the diamonds table in the database. Then we will be able to use that reference with all of our favorite &lt;code&gt;dplyr&lt;/code&gt; verbs.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;diamonds_tbl &amp;lt;- tbl(con, &amp;quot;diamonds&amp;quot;)

diamonds_tbl %&amp;gt;%
  select(carat, cut, clarity, color, price) %&amp;gt;%
  filter(carat &amp;gt; 1, 
         cut == &amp;quot;Ideal&amp;quot;) %&amp;gt;% 
  collect() %&amp;gt;%
  as.tibble()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5,662 x 5
##    carat   cut clarity color price
##    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;
##  1  1.01 Ideal      I1     I  2844
##  2  1.02 Ideal     SI2     H  2856
##  3  1.02 Ideal      I1     I  2872
##  4  1.02 Ideal     SI2     J  2879
##  5  1.01 Ideal      I1     I  2896
##  6  1.02 Ideal      I1     I  2925
##  7  1.14 Ideal     SI1     J  3045
##  8  1.02 Ideal     SI2     H  3142
##  9  1.06 Ideal     SI2     I  3146
## 10  1.02 Ideal     VS2     I  3148
## # ... with 5,652 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;collect&lt;/code&gt; verb is important if you want the full query to be brought into your R session. The &lt;code&gt;dbplyr&lt;/code&gt; package uses lazy evaluation and only brings in a portion of the query into your session.&lt;/p&gt;
&lt;p&gt;Let’s take a look at how these two methods compare using the &lt;code&gt;microbenchmark&lt;/code&gt; package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;microbenchmark::microbenchmark(
  db_query = dbGetQuery(con, query),
  dbplyr = diamonds_tbl %&amp;gt;%
             select(carat, cut, clarity, color, price) %&amp;gt;%
             filter(carat &amp;gt; 1, 
                    cut == &amp;quot;Ideal&amp;quot;) %&amp;gt;% 
             collect()
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Unit: milliseconds
##      expr      min       lq     mean   median       uq      max neval
##  db_query 10.10302 10.30996 10.63014 10.44201 10.60457 15.27123   100
##    dbplyr 51.23319 52.08525 54.66543 53.53378 54.32673 87.69649   100&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, the &lt;code&gt;dbplyr&lt;/code&gt; method, while very familiar and potentially easier if you have no experience writing sql queries, takes nearly 6x as long as the straight sql query.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;modify-tables-in-place&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Modify Tables in Place&lt;/h1&gt;
&lt;p&gt;While there are a lot of blog posts and some great package vignettes about setting up your tables and querying sql databases, there is not too much (that I have seen) about modifying tables in place in your database. There are a few options that are possible when you want to modify a table in a sql database. The first option is to simply query the entire database, make your desired changes using your prefered R tools and then overwrite the table in the database. However, this approach is not practical if you have a large amount of data in your table.&lt;/p&gt;
&lt;p&gt;The method that I have found that seems to be fairly straight forward is using the &lt;code&gt;dbSendQuery&lt;/code&gt; function. While knowing this function is important, the more important part of this function is knowing what SQL commmads to include in your query. The blog post on &lt;a href=&#34;http://www.win-vector.com/blog/2016/02/using-postgresql-in-r/&#34;&gt;Win-Vector Blog&lt;/a&gt; concerning using PostgreSqL in R shows how you can drop entire tables from your database, and the &lt;code&gt;RSQLite&lt;/code&gt; vignette by Hadley Wickham shows how to delete rows that meet certain conditions. However, if you want to modify a table in your database, the sql commands needed are “update” “set”, and “where”. You can see below how we can use these commands.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;update_query &amp;lt;- paste(&amp;quot;update cars&amp;quot;,
                      &amp;quot;set mpg = 20&amp;quot;,
                      &amp;quot;where cyl = 6&amp;quot;)

dbSendQuery(con, update_query)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;lt;SQLiteResult&amp;gt;
##   SQL  update cars set mpg = 20 where cyl = 6
##   ROWS Fetched: 0 [complete]
##        Changed: 7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that 7 rows were changed in the database. Let’s now query the database and see how the table now looks.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dbGetQuery(con, &amp;quot;select * from cars&amp;quot;) %&amp;gt;%
  as.tibble()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 32 x 12
##              rowname   mpg   cyl  disp    hp  drat    wt  qsec    vs    am
##                &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1         Mazda RX4  20.0     6 160.0   110  3.90 2.620 16.46     0     1
##  2     Mazda RX4 Wag  20.0     6 160.0   110  3.90 2.875 17.02     0     1
##  3        Datsun 710  22.8     4 108.0    93  3.85 2.320 18.61     1     1
##  4    Hornet 4 Drive  20.0     6 258.0   110  3.08 3.215 19.44     1     0
##  5 Hornet Sportabout  18.7     8 360.0   175  3.15 3.440 17.02     0     0
##  6           Valiant  20.0     6 225.0   105  2.76 3.460 20.22     1     0
##  7        Duster 360  14.3     8 360.0   245  3.21 3.570 15.84     0     0
##  8         Merc 240D  24.4     4 146.7    62  3.69 3.190 20.00     1     0
##  9          Merc 230  22.8     4 140.8    95  3.92 3.150 22.90     1     0
## 10          Merc 280  20.0     6 167.6   123  3.92 3.440 18.30     1     0
## # ... with 22 more rows, and 2 more variables: gear &amp;lt;dbl&amp;gt;, carb &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It looks like all of the rows where cyl = 6 have had their mpg changed to 20. While this is a somewhat trivial example, as you would most likely not want to change the results for a data set like this, this can be an incredibly useful feature if you are maintaining a database from R.&lt;/p&gt;
&lt;p&gt;You can modify more rows by adding additional arguments to the “set” command and add more conditions by setting additional arguments to the “where” command. For example, we can edit the diamonds table below.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;update_query &amp;lt;- paste(&amp;quot;update diamonds&amp;quot;,
                      &amp;quot;set cut = &amp;#39;new Ideal&amp;#39;,&amp;quot;,
                      &amp;quot;color = &amp;#39;Z&amp;#39;&amp;quot;,
                      &amp;quot;where cut = &amp;#39;Ideal&amp;#39; and&amp;quot;,
                      &amp;quot;color = &amp;#39;E&amp;#39;&amp;quot;)
dbSendQuery(con, update_query)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;lt;SQLiteResult&amp;gt;
##   SQL  update diamonds set cut = &amp;#39;new Ideal&amp;#39;, color = &amp;#39;Z&amp;#39; where cut = &amp;#39;Ideal&amp;#39; and color = &amp;#39;E&amp;#39;
##   ROWS Fetched: 0 [complete]
##        Changed: 3903&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that this changed 3903 rows in the diamonds dataset.&lt;/p&gt;
&lt;p&gt;Before we finish, it is imprtant to remember to disconnect from the in-memory database using the &lt;code&gt;dbDisconnect&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dbDisconnect(con)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;DBI&lt;/code&gt;, &lt;code&gt;odbc&lt;/code&gt;, and &lt;code&gt;dbplyr&lt;/code&gt; packages offer an incredible number of tools for interacting with SQL databases of all different kinds. While you are certainly able to navigate through most SQL query problems with only the functions provided in these packages, you can cartainly increase your capabilites by learning some basic SQL commands and how to use them in conjunction with the R functions provided in these packages.&lt;/p&gt;
&lt;/div&gt;
</description>
  </item>
  
</channel>
  </rss>